<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <div class="buttons">
            <button class="utilButton" id="save">save</button>
            <button class="utilButton" id="undo">undo</button>
            <button class="utilButton" id="reset">reset</button>
            <div class="shapeButtons">
                <button class="shapeButton" id="shapeButton" value="polygon">draw walls</button>
                <button class="utilButton" id="confirm">confirm</button>
                <button class="shapeButton" id="shapeButton" value="rect">draw rectangle</button>
                <button class="shapeButton" id="shapeButton" value="marker">add markers</button>
                <button class="shapeButton" id="shapeButton" value="doorway">add doorways</button>
                <div id="rotationButtons">
                    <button class="utilButton" id="add90">Rotate Right</button>
                    <button class="utilButton" id="minus90">Rotate Left</button>
                </div>
            </div>
        </div>
        <div id="drawing"></div>
    </div>

    <script src="svg.js/dist/svg.js"></script>
    <script src="svg.draw.js/dist/svg.draw.js"></script>
    <script src="dom-to-image/dist/dom-to-image.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // the current shape type being drawn
            let activeShape;

            // where all of the individual svg shapes go
            let shapes = [];

            // init a new drawing 
            let shape, drawing = new SVG('drawing').size('100%', '100%');

            // doorway rotation 
            let doorwayRotation = 180;

            // add click event listeners to utility buttons
            let utilButtons = document.querySelectorAll('.utilButton');
            utilButtons.forEach(btn => {
                btn.addEventListener('click', event => {

                    const id = event.target.id

                    switch (id) {
                        case 'undo':
                            undoShape();
                            return;
                        case 'reset':
                            resetCanvas();
                            return;
                        case 'save':
                            saveCanvas();
                            return;
                        case 'confirm':
                            confirmCurrentShape();
                            return;
                        case 'add90':
                            doorwayRotation += 90;
                            return;
                        case 'minus90':
                            doorwayRotation -= 90;
                            return;
                    }
                })
            })

            // add click event listeners to shape
            let shapeButtons = document.querySelectorAll('.shapeButton');
            shapeButtons.forEach(btn => {
                btn.addEventListener('click', event => {

                    const value = event.target.value

                    // early return if it's the same button being clicked
                    if (activeShape === value) return;

                    // remove active class from other buttons if different one is clicked
                    if (activeShape != value) {
                        shapeButtons.forEach(btn => btn.classList.remove('active'));
                        if (activeShape === 'doorway') {
                            document.getElementById('rotationButtons').style.display = 'none';
                        }
                    }

                    // if there's currently a shape being drawn, finish it
                    if (shape) {
                        // revert shape if going from marker -> doorway without placing anything
                        if (activeShape === 'marker' || activeShape === 'doorway') shape = null;
                        // fix bug with switching to rectangle
                        if (activeShape === 'rect') {
                            shape.draw('cancel');
                        }
                        confirmCurrentShape();
                    }

                    // update current active shape
                    activeShape = value;

                    // add active class to button
                    if (activeShape) document.querySelector(`button[value=${activeShape}`).classList.toggle('active');

                    // switch to handle shape buttons
                    switch (value) {
                        case 'polygon':
                            // show confirm button in place of walls button 
                            document.querySelector('button[value=polygon]').style.display = 'none';
                            document.querySelector('button[id=confirm]').style.display = 'block';
                            shape = drawing.polygon().draw({ snapToGrid: 20 }).attr('stroke-width', 1).attr('fill', 'none');
                            shape.on('drawstart', () => {
                                // listen for enter key press
                                document.addEventListener('keydown', function (e) {
                                    if (e.keyCode == 13) {
                                        confirmCurrentShape();
                                    }
                                });
                            })
                            return;
                        case 'marker':
                            if (shape) shape = null;
                            shape = drawing.circle().draw({ snapToGrid: 20 }).attr('stroke-width', 1).attr('fill', 'none');
                            return;
                        case 'doorway':
                            if (shape) shape = null;
                            document.getElementById('rotationButtons').style.display = 'flex';
                            shape = drawing.attr('stroke-width', 1).attr('fill', 'none');
                            return;
                        case 'rect':
                            if (shape) shape = null;
                            shape = drawing.rect().attr('stroke-width', 1).attr('fill', 'none');
                            return;
                    }
                })
            })

            // allow click and drag to draw rectangle
            drawing.on('mousedown', (e) => {
                if (activeShape === 'rect') {
                    shape && shape.draw(e, { snapToGrid: 20 });
                }
            });

            // end click and draw for rectangle
            drawing.on('mouseup', (e) => {
                if (shape && activeShape === 'rect') {
                    shape.draw('stop');
                    document.querySelector(`button[value=${activeShape}]`).classList.toggle('active');
                    shapes.push(shape);
                    shape = null;
                    activeShape = null;
                }
                document.removeEventListener('keydown', () => { })
            });

            // listen for a click on the canvas
            drawing.on('click', (event) => {
                let { offsetX, offsetY } = event;
                if (activeShape === 'marker' || activeShape === 'doorway') {
                    placeIconAtCursor(offsetX - 10, offsetY - 10);
                    return;
                }
            });

            //  place the type of icon at the location of the click
            const placeIconAtCursor = (x, y) => {
                if (activeShape === 'marker') {
                    shape = drawing
                        .circle()
                        .draw()
                        .radius(10)
                        .move(x, y)
                        .attr({
                            'fill': '#5D69C5',
                            'stroke-width': 0,
                            stroke: '#000'
                        })
                    shapes.push(shape);
                    shape.draw('stop');
                    shape = null;
                    return;
                }
                if (activeShape === 'doorway') {
                    shape = drawing
                        .path("M0,50 a1,1 0 0,0 20,0")
                        .rotate(doorwayRotation, x + 9, y + 5)
                        .move(x, y)
                        .attr({
                            fill: 'none',
                            'stroke-width': 1.5,
                            stroke: '#000'
                        })
                    shapes.push(shape);
                    shape = null;
                    return;
                }
            }

            // complete the current polygon shape
            const confirmCurrentShape = () => {
                if (shape) {
                    document.querySelector('button[id=confirm]').style.display = 'none';
                    document.querySelector('button[value=polygon]').style.display = 'block';
                    document.querySelector('button[value=polygon]').style.background = '#333';
                    shape.draw('done');
                    shapes.push(shape);
                    activeShape = null;
                    shape = null;
                }
            }

            // undo the most recent shape
            const undoShape = () => {
                if (!shapes.length) {
                    return;
                }
                let shapeToUndo = shapes[shapes.length - 1];
                document.getElementById(shapeToUndo.node.id).remove();
                shapes.splice(shapes.indexOf(shapes.length - 1), 1)
            }

            // cleanup the canvas
            const resetCanvas = () => {
                shapeButtons.forEach(btn => btn.classList.remove('active'));
                drawing.clear();
            }

            // export the current canvas as an SVG file
            const saveCanvas = () => {
                if (shapes.length) {
                    domtoimage.toSvg(document.getElementById('drawing'), { style: { position: 'absolute', top: 0, left: 0 } })
                        .then(function (dataUrl) {
                            var link = document.createElement('a');
                            link.href = dataUrl;
                            link.download = 'site-map.svg';
                            link.click();
                        });
                }
            }
        });
    </script>
</body>

</html>